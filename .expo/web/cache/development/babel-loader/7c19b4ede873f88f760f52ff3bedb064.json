{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nvar dataUriPattern = /^data:/;\nexport var ImageUriCache = function () {\n  function ImageUriCache() {\n    _classCallCheck(this, ImageUriCache);\n  }\n\n  _createClass(ImageUriCache, null, [{\n    key: \"has\",\n    value: function has(uri) {\n      var entries = ImageUriCache._entries;\n      var isDataUri = dataUriPattern.test(uri);\n      return isDataUri || Boolean(entries[uri]);\n    }\n  }, {\n    key: \"add\",\n    value: function add(uri) {\n      var entries = ImageUriCache._entries;\n      var lastUsedTimestamp = Date.now();\n\n      if (entries[uri]) {\n        entries[uri].lastUsedTimestamp = lastUsedTimestamp;\n        entries[uri].refCount += 1;\n      } else {\n        entries[uri] = {\n          lastUsedTimestamp: lastUsedTimestamp,\n          refCount: 1\n        };\n      }\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(uri) {\n      var entries = ImageUriCache._entries;\n\n      if (entries[uri]) {\n        entries[uri].refCount -= 1;\n      }\n\n      ImageUriCache._cleanUpIfNeeded();\n    }\n  }, {\n    key: \"_cleanUpIfNeeded\",\n    value: function _cleanUpIfNeeded() {\n      var entries = ImageUriCache._entries;\n      var imageUris = Object.keys(entries);\n\n      if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\n        var leastRecentlyUsedKey;\n        var leastRecentlyUsedEntry;\n        imageUris.forEach(function (uri) {\n          var entry = entries[uri];\n\n          if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\n            leastRecentlyUsedKey = uri;\n            leastRecentlyUsedEntry = entry;\n          }\n        });\n\n        if (leastRecentlyUsedKey) {\n          delete entries[leastRecentlyUsedKey];\n        }\n      }\n    }\n  }]);\n\n  return ImageUriCache;\n}();\nImageUriCache._maximumEntries = 256;\nImageUriCache._entries = {};\nvar id = 0;\nvar requests = {};\nvar ImageLoader = {\n  abort: function abort(requestId) {\n    var image = requests[\"\" + requestId];\n\n    if (image) {\n      image.onerror = null;\n      image.onload = null;\n      image = null;\n      delete requests[\"\" + requestId];\n    }\n  },\n  getSize: function getSize(uri, success, failure) {\n    var complete = false;\n    var interval = setInterval(callback, 16);\n    var requestId = ImageLoader.load(uri, callback, errorCallback);\n\n    function callback() {\n      var image = requests[\"\" + requestId];\n\n      if (image) {\n        var naturalHeight = image.naturalHeight,\n            naturalWidth = image.naturalWidth;\n\n        if (naturalHeight && naturalWidth) {\n          success(naturalWidth, naturalHeight);\n          complete = true;\n        }\n      }\n\n      if (complete) {\n        ImageLoader.abort(requestId);\n        clearInterval(interval);\n      }\n    }\n\n    function errorCallback() {\n      if (typeof failure === 'function') {\n        failure();\n      }\n\n      ImageLoader.abort(requestId);\n      clearInterval(interval);\n    }\n  },\n  has: function has(uri) {\n    return ImageUriCache.has(uri);\n  },\n  load: function load(uri, onLoad, onError) {\n    id += 1;\n    var image = new window.Image();\n    image.onerror = onError;\n\n    image.onload = function (e) {\n      var onDecode = function onDecode() {\n        return onLoad({\n          nativeEvent: e\n        });\n      };\n\n      if (typeof image.decode === 'function') {\n        image.decode().then(onDecode, onDecode);\n      } else {\n        setTimeout(onDecode, 0);\n      }\n    };\n\n    image.src = uri;\n    requests[\"\" + id] = image;\n    return id;\n  },\n  prefetch: function prefetch(uri) {\n    return new Promise(function (resolve, reject) {\n      ImageLoader.load(uri, function () {\n        ImageUriCache.add(uri);\n        ImageUriCache.remove(uri);\n        resolve();\n      }, reject);\n    });\n  },\n  queryCache: function queryCache(uris) {\n    var result = {};\n    uris.forEach(function (u) {\n      if (ImageUriCache.has(u)) {\n        result[u] = 'disk/memory';\n      }\n    });\n    return Promise.resolve(result);\n  }\n};\nexport default ImageLoader;","map":{"version":3,"names":["dataUriPattern","ImageUriCache","uri","entries","_entries","isDataUri","test","Boolean","lastUsedTimestamp","Date","now","refCount","_cleanUpIfNeeded","imageUris","Object","keys","length","_maximumEntries","leastRecentlyUsedKey","leastRecentlyUsedEntry","forEach","entry","id","requests","ImageLoader","abort","requestId","image","onerror","onload","getSize","success","failure","complete","interval","setInterval","callback","load","errorCallback","naturalHeight","naturalWidth","clearInterval","has","onLoad","onError","window","Image","e","onDecode","nativeEvent","decode","then","setTimeout","src","prefetch","Promise","resolve","reject","add","remove","queryCache","uris","result","u"],"sources":["C:/Users/ASUS/Desktop/ChuyenDeDiDongV2/node_modules/react-native-web/dist/modules/ImageLoader/index.js"],"sourcesContent":["/**\r\n * Copyright (c) Nicolas Gallagher.\r\n *\r\n * This source code is licensed under the MIT license found in the\r\n * LICENSE file in the root directory of this source tree.\r\n *\r\n * \r\n */\r\nvar dataUriPattern = /^data:/;\r\nexport class ImageUriCache {\r\n  static has(uri) {\r\n    var entries = ImageUriCache._entries;\r\n    var isDataUri = dataUriPattern.test(uri);\r\n    return isDataUri || Boolean(entries[uri]);\r\n  }\r\n\r\n  static add(uri) {\r\n    var entries = ImageUriCache._entries;\r\n    var lastUsedTimestamp = Date.now();\r\n\r\n    if (entries[uri]) {\r\n      entries[uri].lastUsedTimestamp = lastUsedTimestamp;\r\n      entries[uri].refCount += 1;\r\n    } else {\r\n      entries[uri] = {\r\n        lastUsedTimestamp,\r\n        refCount: 1\r\n      };\r\n    }\r\n  }\r\n\r\n  static remove(uri) {\r\n    var entries = ImageUriCache._entries;\r\n\r\n    if (entries[uri]) {\r\n      entries[uri].refCount -= 1;\r\n    } // Free up entries when the cache is \"full\"\r\n\r\n\r\n    ImageUriCache._cleanUpIfNeeded();\r\n  }\r\n\r\n  static _cleanUpIfNeeded() {\r\n    var entries = ImageUriCache._entries;\r\n    var imageUris = Object.keys(entries);\r\n\r\n    if (imageUris.length + 1 > ImageUriCache._maximumEntries) {\r\n      var leastRecentlyUsedKey;\r\n      var leastRecentlyUsedEntry;\r\n      imageUris.forEach(uri => {\r\n        var entry = entries[uri];\r\n\r\n        if ((!leastRecentlyUsedEntry || entry.lastUsedTimestamp < leastRecentlyUsedEntry.lastUsedTimestamp) && entry.refCount === 0) {\r\n          leastRecentlyUsedKey = uri;\r\n          leastRecentlyUsedEntry = entry;\r\n        }\r\n      });\r\n\r\n      if (leastRecentlyUsedKey) {\r\n        delete entries[leastRecentlyUsedKey];\r\n      }\r\n    }\r\n  }\r\n\r\n}\r\nImageUriCache._maximumEntries = 256;\r\nImageUriCache._entries = {};\r\nvar id = 0;\r\nvar requests = {};\r\nvar ImageLoader = {\r\n  abort(requestId) {\r\n    var image = requests[\"\" + requestId];\r\n\r\n    if (image) {\r\n      image.onerror = null;\r\n      image.onload = null;\r\n      image = null;\r\n      delete requests[\"\" + requestId];\r\n    }\r\n  },\r\n\r\n  getSize(uri, success, failure) {\r\n    var complete = false;\r\n    var interval = setInterval(callback, 16);\r\n    var requestId = ImageLoader.load(uri, callback, errorCallback);\r\n\r\n    function callback() {\r\n      var image = requests[\"\" + requestId];\r\n\r\n      if (image) {\r\n        var naturalHeight = image.naturalHeight,\r\n            naturalWidth = image.naturalWidth;\r\n\r\n        if (naturalHeight && naturalWidth) {\r\n          success(naturalWidth, naturalHeight);\r\n          complete = true;\r\n        }\r\n      }\r\n\r\n      if (complete) {\r\n        ImageLoader.abort(requestId);\r\n        clearInterval(interval);\r\n      }\r\n    }\r\n\r\n    function errorCallback() {\r\n      if (typeof failure === 'function') {\r\n        failure();\r\n      }\r\n\r\n      ImageLoader.abort(requestId);\r\n      clearInterval(interval);\r\n    }\r\n  },\r\n\r\n  has(uri) {\r\n    return ImageUriCache.has(uri);\r\n  },\r\n\r\n  load(uri, onLoad, onError) {\r\n    id += 1;\r\n    var image = new window.Image();\r\n    image.onerror = onError;\r\n\r\n    image.onload = e => {\r\n      // avoid blocking the main thread\r\n      var onDecode = () => onLoad({\r\n        nativeEvent: e\r\n      });\r\n\r\n      if (typeof image.decode === 'function') {\r\n        // Safari currently throws exceptions when decoding svgs.\r\n        // We want to catch that error and allow the load handler\r\n        // to be forwarded to the onLoad handler in this case\r\n        image.decode().then(onDecode, onDecode);\r\n      } else {\r\n        setTimeout(onDecode, 0);\r\n      }\r\n    };\r\n\r\n    image.src = uri;\r\n    requests[\"\" + id] = image;\r\n    return id;\r\n  },\r\n\r\n  prefetch(uri) {\r\n    return new Promise((resolve, reject) => {\r\n      ImageLoader.load(uri, () => {\r\n        // Add the uri to the cache so it can be immediately displayed when used\r\n        // but also immediately remove it to correctly reflect that it has no active references\r\n        ImageUriCache.add(uri);\r\n        ImageUriCache.remove(uri);\r\n        resolve();\r\n      }, reject);\r\n    });\r\n  },\r\n\r\n  queryCache(uris) {\r\n    var result = {};\r\n    uris.forEach(u => {\r\n      if (ImageUriCache.has(u)) {\r\n        result[u] = 'disk/memory';\r\n      }\r\n    });\r\n    return Promise.resolve(result);\r\n  }\r\n\r\n};\r\nexport default ImageLoader;"],"mappings":"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"},"metadata":{},"sourceType":"module"}